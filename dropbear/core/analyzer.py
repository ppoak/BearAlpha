import pandas as pd
import matplotlib.pyplot as plt
import statsmodels.api as sm
from .base import DataCollection, Data


class AnalyzeData(DataCollection):
    '''A Collection of the Standarized Data Used for Analysis
    ========================================================
    
    AnalyzeData can only contain Data class data,
    and specifically, DataCollection is used for getting ready
    for subsequent analysis.
    '''
    def __init__(self, factor: 'Data', 
        forward: 'Data' = None, 
        price: 'Data' = None, 
        group: 'Data' = None,
        infer_forward: 'str | list' = None, *args) -> 'None':
        '''DataCollection is used for getting ready for subsequent analysis
        --------------------------------------------------------------------

        factor: Data, the factor data
        forward: Data or None, the forward data
        price: Data or None, the price data
        group: Data or None, the group data
        infer_forward: str or list, the forward data will be inferred from
        '''
        super().__init__(*args)
        if isinstance(infer_forward, str):
            infer_forward = [infer_forward]

        if infer_forward is not None and price is not None:
            if forward is not None:
                print(f'[!] forward is not None, infer_forward {infer_forward} cover forward')
            forward = self.__infer_forward_from_price(price, infer_forward)
        
        self.factor = factor
        self.forward = forward if forward is not None else Data(name='forward')
        self.price = price if price is not None else Data(name='price')
        self.group = group if group is not None else Data(name='group')
        self.data_dict.update({
            "factor": self.factor,
            "forward": self.forward,
            "price": self.price,
            "group": self.group
        })

    def __infer_forward_from_price(self, price: 'Data', infer_forward: 'list') -> 'pd.Series':
        '''infer forward return from ohlc price data'''
        def _infer(start_name: 'str', end_name: 'str') -> 'dict':
            forward = {}
            for iff in infer_forward:
                price_start = price[start_name].resample(iff).first()
                price_end = price[end_name].resample(iff).last()
                forward[iff] = (price_end - price_start) / price_start
            return forward

        price = price.copy()
        has_close = price.get('close', False)
        has_open = price.get('open', False)
        if len(price) == 1:
            forward = _infer(price.indicators[0], price.indicators[0])
        elif not has_close and not has_open:
            raise ValueError('Ambiguous infer forward, Please calculate manually')
        elif not has_close and has_open:
            print('[!] Not find close price, infer forward from open price')
            forward = _infer('open', 'open')
        elif has_close and not has_open:
            print('[!] Not find open price, use close price to infer forward')
            forward = _infer('close', 'close')
        else:
            forward = _infer('open', 'close')

        return Data(name="forward", **forward)

    def __bool__(self) -> bool:
        return self.price.__bool__() or self.forward.__bool__()

class Analyzer(object):
    def __init__(self, data: pd.DataFrame):
        self.data = data
    
    def __reg(self, data: pd.DataFrame, factor: str, period: str) -> pd.DataFrame:
        '''Calculate factor regression results for single
        forward return period and one specific factor'''
        data = data.copy()
        grp = pd.get_dummies(data['group']).iloc[:, :-1]
        x = pd.concat([data[factor], grp], axis=1)
        y = data.loc[:, period]
        x = sm.add_constant(x)
        model = sm.OLS(y, x).fit()
        t = model.tvalues[factor]
        coef = model.params[factor]
        return pd.Series({f't_{period}': t, f'coef_{period}': coef})
    
    def reg_(self, factor: str, period: str) -> pd.DataFrame:
        '''Calculate factor regression results for single
        forward return period and one specific factor'''
        data = self.data.loc[:, [factor, period, 'group']].copy()
        reg_res = data.groupby(level='date').apply(self.__reg, factor=factor, period=period)
        return reg_res
    
    def regression(self) -> pd.DataFrame:
        '''Calculate factor regression results
        --------------------------------------

        data: pd.DataFrame, data must be in the standard format
            generated by function `factor_datas_and_forward_returns`
            in factor/utils/prepare.py
        return: pd.DataFrame, a dataframe with multi-index and columns
            one is t value for each regression; another is coefficient
        '''
        data = self.data.copy()
        factors = get_factor_columns(data)
        forward = get_forward_return_columns(data)

        results = pd.DataFrame()
        for factor in factors:
            period_result = []
            for period in forward:
                result = data.groupby(level='date').apply(self.__reg, factor=factor, period=period)
                result.index = pd.MultiIndex.from_product([[factor], result.index], names=['factor', 'date'])
                period_result.append(result)
            results = results.append(pd.concat(period_result, axis=1))
        self.reg_result = results
        return results
    
    def _reg_plot(self, ax: plt.Axes, factor: str, period: str):
        '''Plot factor regression results for single
        factor and one specific forward return period'''
        data = self.reg_result.loc[factor, [f't_{period}', f'coef_{period}']].copy()
        ax.set_title(f'regression: {factor} - {period}', fontsize=20)
        ax.bar(data.index, data[f'coef_{period}'], color='b', width=8, label=f'coef_{period}')
        ax.hlines(0, data.index[0], data.index[-1], color='k', linestyle='-.')
        ax = ax.twinx()
        ax.plot(data.index, data[f't_{period}'], color='r', label=f't_{period}')
        ax.hlines(2, data.index[0], data.index[-1], color='g', linestyle='--')
        ax.hlines(-2, data.index[0], data.index[-1], color='g', linestyle='--')
        ax.legend(loc='best')

    def regression_plot(self, path: str = None) -> None:
        '''Regression Result Plot
        -------------------------

        regression_result: pd.DataFrame, standardized result generated from regression function
        path: str, path to save the plot, default is None, which means show the plot
        '''
        factors = self.reg_result.index.levels[0]
        periods = set(self.reg_result.columns.map(lambda x: x.split('_')[-1]))
        
        _, axes = plt.subplots(len(factors), len(periods), 
            figsize=(len(periods) * 17, len(factors) * 10))
        if len(factors) == 1 and len(periods) == 1:
            axes = np.array([[axes]])
        elif len(factors) == 1 and len(periods) > 1:
            axes = axes.reshape(1, -1)
        elif len(factors) > 1 and len(periods) == 1:
            axes = axes.reshape(-1, 1)

        for i, factor in enumerate(factors):
            for j, period in enumerate(periods):
                self._reg_plot(axes[i, j], factor, period)

        if path is not None:
            plt.savefig(path, bbox_inches='tight')
        else:
            plt.show()

    def __ic(self, data: pd.DataFrame, factor: str, period: str) -> pd.Series:
        '''Calculate factor ic results for single 
        forward return period and one specific factor'''
        data = data.copy()
        res = data.corr(method='spearman')
        val = res.loc[factor, period]
        return pd.Series({f"ic_{period}": val})
    
    def ic_(self, factor: str, period: str) -> pd.Series:
        '''Calculate factor ic results for single 
        forward return period and one specific factor'''
        data = self.data.loc[:, [factor, period]].copy()
        ic_res = data.groupby(level='date').apply(self.__ic, factor=factor, period=period)
        return ic_res

    def ic(self) -> pd.DataFrame:
        '''Calculate factor ic results
        --------------------------------------

        data: pd.DataFrame, data must be in the standard format
            generated by function `factor_datas_and_forward_returns`
            in factor/utils/prepare.py
        return: pd.DataFrame, a dataframe with multi-index and columns
        '''        
        data = self.data.copy()
        factors = get_factor_columns(data)
        forward = get_forward_return_columns(data)

        results = pd.DataFrame()
        for factor in factors:
            period_result = []
            for period in forward:
                result = data.groupby(level='date').apply(self.__ic, factor=factor, period=period)
                result.index = pd.MultiIndex.from_product([[factor], result.index], names=['factor', 'date'])
                period_result.append(result)
            results = results.append(pd.concat(period_result, axis=1))
        self.ic_result = results
        return results

    def _ic_plot(self, ax: plt.Axes, factor: str, period: str):
        '''Plot factor ic results for single
        factor and one specific forward return period'''
        data = self.ic_result.loc[factor, [f'ic_{period}']].copy()
        data.index = pd.to_datetime(data.index)
        ax.set_title(f'ic: {factor} - {period}', fontsize=20)
        ax.bar(data.index, data[f'ic_{period}'], color='b', width=8)
        ax.hlines(0, data.index[0], data.index[-1], color='k', linestyle='-.')

    def ic_plot(self, path: str = None) -> None:
        '''IC Result Plot
        -------------------------

        ic_result: pd.DataFrame, standardized result generated from ic function
        path: str, path to save the plot, default is None, which means show the plot
        '''
        factors = self.ic_result.index.levels[0]
        periods = set(self.ic_result.columns.map(lambda x: x.split('_')[-1]))
        
        _, axes = plt.subplots(len(factors), len(periods), 
            figsize=(len(periods) * 17, len(factors) * 10))
        if len(factors) == 1 and len(periods) == 1:
            axes = np.array([[axes]])
        elif len(factors) == 1 and len(periods) > 1:
            axes = axes.reshape(1, -1)
        elif len(factors) > 1 and len(periods) == 1:
            axes = axes.reshape(-1, 1)

        for i, factor in enumerate(factors):
            for j, period in enumerate(periods):
                self._ic_plot(axes[i, j], factor, period)

        if path is not None:
            plt.savefig(path, bbox_inches='tight')
        else:
            plt.show()

    def __layer(self, data: pd.DataFrame, factor: str, period: str) -> pd.DataFrame:
        '''Calculate factor layering results for single
        forward return period and one specific factor'''
        data = data.copy()
        data[f'{factor}_weight'] = 1
        profit = self.__profit(data, weight_col=f'{factor}_weight', forward_col=period)
        return profit
    
    def layer_(self, factor: str, period: str, quantiles: int = 5) -> pd.DataFrame:
        '''Calculate factor layering results for single
        forward return period and one specific factor'''
        data = self.data.loc[:, [factor, period]].copy()
        quant = data[factor].groupby(level='date').apply(pd.qcut, q=quantiles, labels=False, duplicates='drop')
        data['quantiles'] = quant + 1
        layer_res = data.groupby('quantiles').apply(self.__layer, factor=factor, period=period)
        return layer_res

    def layering(self, quantiles: int = 5) -> pd.DataFrame:
        '''Calculate factor layering results
        --------------------------------------

        data: pd.DataFrame, data must be in the standard format
            generated by function `factor_datas_and_forward_returns`
            in factor/utils/prepare.py
        return: pd.DataFrame, a dataframe with multi-index and columns
        '''
        data = self.data.copy()
        factors = get_factor_columns(data)
        forward = get_forward_return_columns(data)

        results = pd.DataFrame()
        for factor in factors:
            period_result = []
            for period in forward:
                quant = data[factor].groupby(level='date').apply(
                    pd.qcut, q=quantiles, labels=False, duplicates='drop')
                data[f'quantiles_{factor}'] = quant + 1
                result = data.groupby(by=f'quantiles_{factor}').apply(self.__layer, factor=factor, period=period)
                result.index = pd.MultiIndex.from_arrays(
                    [[factor] * len(result), result.index.get_level_values(0), result.index.get_level_values(1)],
                    names = ['factor', 'quantiles', 'date'])
                period_result.append(result)
            results = results.append(pd.concat(period_result, axis=1))
        self.layer_result = results
        return results

    def _layer_plot(self, ax: plt.Axes, factor: str, period: str):
        '''Plot factor layering results for single
        factor and one specific forward return period'''
        data = self.layer_result.loc[factor, [f'profit_{period}', f'cum_profit_{period}']].copy()
        data = data.unstack(level=0)
        quantiles = data.columns.get_level_values(1).unique()
        ax.set_title(f'layering: {factor} - {period}', fontsize=20)
        for q in quantiles:
            bottom = data[(f'profit_{period}', q - 1)] if q > 1 else [0] * len(data.index)
            ax.bar(data.index, data[(f'profit_{period}', q)], bottom=bottom, width=8, label=q)
        ax.hlines(0, data.index[0], data.index[-1], color='k', linestyle='-.')
        ax.legend(loc='best')
        ax = ax.twinx()
        for q in quantiles:
            ax.plot(data.index, data[(f'cum_profit_{period}', q)], label=q)
        ax.legend(loc='best')    

    def layering_plot(self, path: str = None) -> None:
        '''Layering Result Plot
        -------------------------

        layering_result: pd.DataFrame, standardized result generated from layering function
        path: str, path to save the plot, default is None, which means show the plot
        '''
        factors = self.layer_result.index.levels[0]
        periods = set(self.layer_result.columns.map(lambda x: x.split('_')[-1]))
        
        _, axes = plt.subplots(len(factors), len(periods), 
            figsize=(len(periods) * 17, len(factors) * 10))
        if len(factors) == 1 and len(periods) == 1:
            axes = np.array([[axes]])
        elif len(factors) == 1 and len(periods) > 1:
            axes = axes.reshape(1, -1)
        elif len(factors) > 1 and len(periods) == 1:
            axes = axes.reshape(-1, 1)

        for i, factor in enumerate(factors):
            for j, period in enumerate(periods):
                self._layer_plot(axes[i, j], factor, period)

        if path is not None:
            plt.savefig(path, bbox_inches='tight')
        else:
            plt.show()

    def __profit(self, data: pd.DataFrame, weight_col: str, forward_col: str) -> pd.DataFrame:
        '''Calculate portfolio holding profit for single
        weight column and specific forward return column'''
        data = data.copy()
        profit = data.groupby(level='date').apply(lambda x:
            (x[weight_col] * x[forward_col] / x[weight_col].sum()).sum())
        profit = profit.sort_index()
        profit = profit.shift(1).fillna(0)
        profit.name = f'profit_{forward_col}'
        cumprofit = (profit + 1).cumprod()
        cumprofit.name = f'cum_profit_{forward_col}'
        result = pd.concat([profit, cumprofit], axis=1)
        return result

    def profit_(self, weight_col: str, forward_col: str) -> pd.DataFrame:
        '''Calculate portfolio holding profit for single
        weight column and specific forward return column'''
        data = self.data.loc[:, [weight_col, forward_col]].copy()
        profit_res = self.__profit(data, weight_col=weight_col, forward_col=forward_col)
        return profit_res

    def holding_profit(self) -> pd.Series:
        '''Calculate holding networth from given data
        ---------------------------------------------

        holding_record: pd.DataFrame, a dataframe with a two-demensional index
            level 0 is the datetime on each reloacte date, level 1 is the asset name
            the column must contain forward return column representing forward return
            `weight` column is optional, if not given, equal weights will be applied.
        return: pd.DataFrame, a dataframe contains networth on each relocate date
        '''
        data = self.data.copy()
        weight_columns = data.columns[data.columns.str.contains('weight')]
        if weight_columns.empty:
            data['weight'] = 1
            weight_columns = ['weight']
        forward_column = get_forward_return_columns(data)
        profits = pd.DataFrame()
        for weight_col in weight_columns:
            forward_result = []
            for forward_col in forward_column:
                profit = self.__profit(data, weight_col=weight_col, forward_col=forward_col)
                profit.index = pd.MultiIndex.from_product([[weight_col], profit.index], names=['weight', 'date'])
                forward_result.append(profit)
            profits = profits.append(pd.concat(forward_result, axis=1))
        self.profits = profits
        return profits

    def _hold_plot(self, ax: plt.Axes, weight: str, period: str):
        '''Plot portfolio holding profit for single
        weight column and specific forward return period'''
        data = self.profits.loc[weight, [f'profit_{period}', f'cum_profit_{period}']].copy()
        ax.set_title(f'layering: {weight} - {period}', fontsize=20)
        ax.bar(data.index, data[f'profit_{period}'], width=8)
        ax.hlines(0, data.index[0], data.index[-1], color='k', linestyle='-.')
        ax = ax.twinx()
        ax.plot(data.index, data[f'cum_profit_{period}'])

    def holding_plot(self, path: str = None) -> None:
        '''Holding Result Plot
        -------------------------

        profits: pd.DataFrame, standardized result generated from holding_profit function
        path: str, path to save the plot, default is None, which means show the plot
        '''
        weights = self.profits.index.levels[0]
        periods = set(self.profits.columns.map(lambda x: x.split('_')[-1]))
        
        _, axes = plt.subplots(len(weights), len(periods), 
            figsize=(len(periods) * 17, len(weights) * 10))
        if len(weights) == 1 and len(periods) == 1:
            axes = np.array([[axes]])
        elif len(weights) == 1 and len(periods) > 1:
            axes = axes.reshape(1, -1)
        elif len(weights) > 1 and len(periods) == 1:
            axes = axes.reshape(-1, 1)

        for i, weight in enumerate(weights):
            for j, period in enumerate(periods):
                self._hold_plot(axes[i, j], weight, period)

        if path is not None:
            plt.savefig(path, bbox_inches='tight')
        else:
            plt.show()

class Aanalyzer(object):
    '''Analyzer is a general analyst dedicated to analyze the AnalyzeData
    =====================================================================

    Analyzer takes one collection of data in AnalyzeData class, heriting from
    DataCollection. There mainly three method of analyzing factor data:

    1. Barra Regression Model
    2. IC value
    3. Layering value

    They can be easily used by calling the method of the class.    
    '''
    def __init__(self, data: 'AnalyzeData'):
        '''Analyzer is a general analyst dedicated to analyze the AnalyzeData
        ---------------------------------------------------------------------

        collection: AnalyzeData, the collection of data
        '''
        self.data = data
        self.df = data.df
        self.factor = data.factor.df
        self.forward = data.forward.df
        self.price = data.price.df
        self.group = data.group.df
    
    def regression(self, factor: 'str | list' = None, period: 
            'str | list' = None, group: 'str | list' = None):
        '''Barra Regression Model
        -----------------------

        factor: str, the factor name
        period: str, the period of regression
        '''
        def _reg(d):
            d = d.copy()
            dg = pd.get_dummies(d.loc[:, ('group', g)]).iloc[:, :-1]
            x = pd.concat([d.loc[:, 'factor'], dg], axis=1)
            x = sm.add_constant(x)
            y = d.loc[:, ('forward', p)]
            model = sm.OLS(y, x).fit()
            t = model.tvalues[f]
            coef = model.params[f]
            return pd.Series({f't': t, f'coef': coef})
            
        if isinstance(factor, str):
            factor = [factor]
        if isinstance(period, str):
            period = [period]
        if isinstance(group, str):
            group = [group]

        if factor is None:
            factor = self.data.factor.indicators
        if period is None:
            period = self.data.forward.indicators
        if group is None:
            group = self.data.group.indicators
        
        results = {}
        for f in factor:
            for p in period:
                for g in group:
                    reg_data = self.df.loc[:, [('factor', f), ('forward', p), ('group', g)]].copy()
                    results[f"{f}_{p}_{g}"] = reg_data.groupby(level='datetime').apply(_reg)
        
        results = Data('regression_result', **results)
        self.reg_result = results
        return results

    def ic(self, factor: 'str | list' = None, period: 'str | list' = None):
        '''IC value
        ----------

        factor: str, the factor name
        period: str, the period of regression
        '''
        def _ic(d):
            d = d.copy()
            cor = d.corr(method='spearman')
            return pd.Series({f'ic': cor.loc[('factor', f), ('forward', p)]})
            
        if isinstance(factor, str):
            factor = [factor]
        if isinstance(period, str):
            period = [period]

        if factor is None:
            factor = self.data.factor.indicators
        if period is None:
            period = self.data.forward.indicators
        
        results = {}
        for f in factor:
            for p in period:
                ic_data = self.df.loc[:, [('factor', f), ('forward', p)]].copy()
                results[f"{f}_{p}"] = ic_data.groupby(level='datetime').apply(_ic)
        
        results = Data('ic_result', **results)
        self.ic_result = results
        return results

    def layering(self, factor: 'str | list' = None, period: 'str | list' = None, quantiles: int = 5):
        '''Layering value
        ----------------

        factor: str, the factor name
        period: str, the period of regression
        '''
        def _layering(d):
            d = d.copy()
            profit = d.groupby(level='datetime').apply(lambda x:x.loc[:, ('forward', p)].mean())
            profit = profit.shift(1).fillna(0)
            cumprofit = (profit + 1).cumprod()
            return pd.DataFrame({"profit": profit, "cumprofit": cumprofit})
            
        if isinstance(factor, str):
            factor = [factor]
        if isinstance(period, str):
            period = [period]

        if factor is None:
            factor = self.data.factor.indicators
        if period is None:
            period = self.data.forward.indicators
        
        results = {}
        for f in factor:
            for p in period:
                layering_data = self.df.loc[:, [('factor', f), ('forward', p)]].copy()
                layering_data.loc[:, 'quantiles'] = layering_data.loc[:, ('factor', f)].groupby(level='datetime').apply(
                    pd.qcut, q=quantiles, duplicates='drop', labels=False) + 1
                results[f"{f}_{p}"] = layering_data.groupby('quantiles').apply(_layering)
        
        results = Data('layering_result', **results)
        self.layering_result = results
        return results

    def regression_plot(self, path: str = None):
        pass
    
if __name__ == "__main__":
    import numpy as np
    a = pd.DataFrame(np.random.rand(100, 5), index=pd.date_range('20210101', periods=100),
        columns=['a', 'b', 'c', 'd', 'e'])
    b = pd.DataFrame(np.random.rand(500, 5), index=pd.MultiIndex.from_product(
        [pd.date_range('20210101', periods=100), list('abcde')]),
        columns=['id1', 'id2', 'id3', 'id4', 'id5'])
    c = pd.Series(np.random.rand(500), index=pd.MultiIndex.from_product(
        [pd.date_range('20210101', periods=100), list('abcde')]), name='id6')
    data = AnalyzeData(factor=Data('', b), forward=Data('', m1=a), group=Data('', c))
    analyzer = Aanalyzer(data)
    analyzer.regression()
