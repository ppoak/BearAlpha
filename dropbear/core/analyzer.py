import pandas as pd
import matplotlib.pyplot as plt
import statsmodels.api as sm
from ..utils.prepare import *


class Analyzer(object):
    def __init__(self, data: pd.DataFrame):
        self.data = data
    
    def __reg(self, data: pd.DataFrame, factor: str, period: str) -> pd.DataFrame:
        '''Calculate factor regression results for single
        forward return period and one specific factor'''
        data = data.copy()
        grp = pd.get_dummies(data['group']).iloc[:, :-1]
        x = pd.concat([data[factor], grp], axis=1)
        y = data.loc[:, period]
        x = sm.add_constant(x)
        model = sm.OLS(y, x).fit()
        t = model.tvalues[factor]
        coef = model.params[factor]
        return pd.Series({f't_{period}': t, f'coef_{period}': coef})
    
    def reg_(self, factor: str, period: str) -> pd.DataFrame:
        '''Calculate factor regression results for single
        forward return period and one specific factor'''
        data = self.data.loc[:, [factor, period, 'group']].copy()
        reg_res = data.groupby(level='date').apply(self.__reg, factor=factor, period=period)
        return reg_res
    
    def regression(self) -> pd.DataFrame:
        '''Calculate factor regression results
        --------------------------------------

        data: pd.DataFrame, data must be in the standard format
            generated by function `factor_datas_and_forward_returns`
            in factor/utils/prepare.py
        return: pd.DataFrame, a dataframe with multi-index and columns
            one is t value for each regression; another is coefficient
        '''
        data = self.data.copy()
        factors = get_factor_columns(data)
        forward = get_forward_return_columns(data)

        results = pd.DataFrame()
        for factor in factors:
            period_result = []
            for period in forward:
                result = data.groupby(level='date').apply(self.__reg, factor=factor, period=period)
                result.index = pd.MultiIndex.from_product([[factor], result.index], names=['factor', 'date'])
                period_result.append(result)
            results = results.append(pd.concat(period_result, axis=1))
        self.reg_result = results
        return results
    
    def _reg_plot(self, ax: plt.Axes, factor: str, period: str):
        '''Plot factor regression results for single
        factor and one specific forward return period'''
        data = self.reg_result.loc[factor, [f't_{period}', f'coef_{period}']].copy()
        ax.set_title(f'regression: {factor} - {period}', fontsize=20)
        ax.bar(data.index, data[f'coef_{period}'], color='b', width=8, label=f'coef_{period}')
        ax.hlines(0, data.index[0], data.index[-1], color='k', linestyle='-.')
        ax = ax.twinx()
        ax.plot(data.index, data[f't_{period}'], color='r', label=f't_{period}')
        ax.hlines(2, data.index[0], data.index[-1], color='g', linestyle='--')
        ax.hlines(-2, data.index[0], data.index[-1], color='g', linestyle='--')
        ax.legend(loc='best')

    def regression_plot(self, path: str = None) -> None:
        '''Regression Result Plot
        -------------------------

        regression_result: pd.DataFrame, standardized result generated from regression function
        path: str, path to save the plot, default is None, which means show the plot
        '''
        factors = self.reg_result.index.levels[0]
        periods = set(self.reg_result.columns.map(lambda x: x.split('_')[-1]))
        
        _, axes = plt.subplots(len(factors), len(periods), 
            figsize=(len(periods) * 17, len(factors) * 10))
        if len(factors) == 1 and len(periods) == 1:
            axes = np.array([[axes]])
        elif len(factors) == 1 and len(periods) > 1:
            axes = axes.reshape(1, -1)
        elif len(factors) > 1 and len(periods) == 1:
            axes = axes.reshape(-1, 1)

        for i, factor in enumerate(factors):
            for j, period in enumerate(periods):
                self._reg_plot(axes[i, j], factor, period)

        if path is not None:
            plt.savefig(path, bbox_inches='tight')
        else:
            plt.show()

    def __ic(self, data: pd.DataFrame, factor: str, period: str) -> pd.Series:
        '''Calculate factor ic results for single 
        forward return period and one specific factor'''
        data = data.copy()
        res = data.corr(method='spearman')
        val = res.loc[factor, period]
        return pd.Series({f"ic_{period}": val})
    
    def ic_(self, factor: str, period: str) -> pd.Series:
        '''Calculate factor ic results for single 
        forward return period and one specific factor'''
        data = self.data.loc[:, [factor, period]].copy()
        ic_res = data.groupby(level='date').apply(self.__ic, factor=factor, period=period)
        return ic_res

    def ic(self) -> pd.DataFrame:
        '''Calculate factor ic results
        --------------------------------------

        data: pd.DataFrame, data must be in the standard format
            generated by function `factor_datas_and_forward_returns`
            in factor/utils/prepare.py
        return: pd.DataFrame, a dataframe with multi-index and columns
        '''        
        data = self.data.copy()
        factors = get_factor_columns(data)
        forward = get_forward_return_columns(data)

        results = pd.DataFrame()
        for factor in factors:
            period_result = []
            for period in forward:
                result = data.groupby(level='date').apply(self.__ic, factor=factor, period=period)
                result.index = pd.MultiIndex.from_product([[factor], result.index], names=['factor', 'date'])
                period_result.append(result)
            results = results.append(pd.concat(period_result, axis=1))
        self.ic_result = results
        return results

    def _ic_plot(self, ax: plt.Axes, factor: str, period: str):
        '''Plot factor ic results for single
        factor and one specific forward return period'''
        data = self.ic_result.loc[factor, [f'ic_{period}']].copy()
        data.index = pd.to_datetime(data.index)
        ax.set_title(f'ic: {factor} - {period}', fontsize=20)
        ax.bar(data.index, data[f'ic_{period}'], color='b', width=8)
        ax.hlines(0, data.index[0], data.index[-1], color='k', linestyle='-.')

    def ic_plot(self, path: str = None) -> None:
        '''IC Result Plot
        -------------------------

        ic_result: pd.DataFrame, standardized result generated from ic function
        path: str, path to save the plot, default is None, which means show the plot
        '''
        factors = self.ic_result.index.levels[0]
        periods = set(self.ic_result.columns.map(lambda x: x.split('_')[-1]))
        
        _, axes = plt.subplots(len(factors), len(periods), 
            figsize=(len(periods) * 17, len(factors) * 10))
        if len(factors) == 1 and len(periods) == 1:
            axes = np.array([[axes]])
        elif len(factors) == 1 and len(periods) > 1:
            axes = axes.reshape(1, -1)
        elif len(factors) > 1 and len(periods) == 1:
            axes = axes.reshape(-1, 1)

        for i, factor in enumerate(factors):
            for j, period in enumerate(periods):
                self._ic_plot(axes[i, j], factor, period)

        if path is not None:
            plt.savefig(path, bbox_inches='tight')
        else:
            plt.show()

    def __layer(self, data: pd.DataFrame, factor: str, period: str) -> pd.DataFrame:
        '''Calculate factor layering results for single
        forward return period and one specific factor'''
        data = data.copy()
        data[f'{factor}_weight'] = 1
        profit = self.__profit(data, weight_col=f'{factor}_weight', forward_col=period)
        return profit
    
    def layer_(self, factor: str, period: str, quantiles: int = 5) -> pd.DataFrame:
        '''Calculate factor layering results for single
        forward return period and one specific factor'''
        data = self.data.loc[:, [factor, period]].copy()
        quant = data[factor].groupby(level='date').apply(pd.qcut, q=quantiles, labels=False, duplicates='drop')
        data['quantiles'] = quant + 1
        layer_res = data.groupby('quantiles').apply(self.__layer, factor=factor, period=period)
        return layer_res

    def layering(self, quantiles: int = 5) -> pd.DataFrame:
        '''Calculate factor layering results
        --------------------------------------

        data: pd.DataFrame, data must be in the standard format
            generated by function `factor_datas_and_forward_returns`
            in factor/utils/prepare.py
        return: pd.DataFrame, a dataframe with multi-index and columns
        '''
        data = self.data.copy()
        factors = get_factor_columns(data)
        forward = get_forward_return_columns(data)

        results = pd.DataFrame()
        for factor in factors:
            period_result = []
            for period in forward:
                quant = data[factor].groupby(level='date').apply(
                    pd.qcut, q=quantiles, labels=False, duplicates='drop')
                data[f'quantiles_{factor}'] = quant + 1
                result = data.groupby(by=f'quantiles_{factor}').apply(self.__layer, factor=factor, period=period)
                result.index = pd.MultiIndex.from_arrays(
                    [[factor] * len(result), result.index.get_level_values(0), result.index.get_level_values(1)],
                    names = ['factor', 'quantiles', 'date'])
                period_result.append(result)
            results = results.append(pd.concat(period_result, axis=1))
        self.layer_result = results
        return results

    def _layer_plot(self, ax: plt.Axes, factor: str, period: str):
        '''Plot factor layering results for single
        factor and one specific forward return period'''
        data = self.layer_result.loc[factor, [f'profit_{period}', f'cum_profit_{period}']].copy()
        data = data.unstack(level=0)
        quantiles = data.columns.get_level_values(1).unique()
        ax.set_title(f'layering: {factor} - {period}', fontsize=20)
        for q in quantiles:
            bottom = data[(f'profit_{period}', q - 1)] if q > 1 else [0] * len(data.index)
            ax.bar(data.index, data[(f'profit_{period}', q)], bottom=bottom, width=8, label=q)
        ax.hlines(0, data.index[0], data.index[-1], color='k', linestyle='-.')
        ax.legend(loc='best')
        ax = ax.twinx()
        for q in quantiles:
            ax.plot(data.index, data[(f'cum_profit_{period}', q)], label=q)
        ax.legend(loc='best')    

    def layering_plot(self, path: str = None) -> None:
        '''Layering Result Plot
        -------------------------

        layering_result: pd.DataFrame, standardized result generated from layering function
        path: str, path to save the plot, default is None, which means show the plot
        '''
        factors = self.layer_result.index.levels[0]
        periods = set(self.layer_result.columns.map(lambda x: x.split('_')[-1]))
        
        _, axes = plt.subplots(len(factors), len(periods), 
            figsize=(len(periods) * 17, len(factors) * 10))
        if len(factors) == 1 and len(periods) == 1:
            axes = np.array([[axes]])
        elif len(factors) == 1 and len(periods) > 1:
            axes = axes.reshape(1, -1)
        elif len(factors) > 1 and len(periods) == 1:
            axes = axes.reshape(-1, 1)

        for i, factor in enumerate(factors):
            for j, period in enumerate(periods):
                self._layer_plot(axes[i, j], factor, period)

        if path is not None:
            plt.savefig(path, bbox_inches='tight')
        else:
            plt.show()

    def __profit(self, data: pd.DataFrame, weight_col: str, forward_col: str) -> pd.DataFrame:
        '''Calculate portfolio holding profit for single
        weight column and specific forward return column'''
        data = data.copy()
        profit = data.groupby(level='date').apply(lambda x:
            (x[weight_col] * x[forward_col] / x[weight_col].sum()).sum())
        profit = profit.sort_index()
        profit = profit.shift(1).fillna(0)
        profit.name = f'profit_{forward_col}'
        cumprofit = (profit + 1).cumprod()
        cumprofit.name = f'cum_profit_{forward_col}'
        result = pd.concat([profit, cumprofit], axis=1)
        return result

    def profit_(self, weight_col: str, forward_col: str) -> pd.DataFrame:
        '''Calculate portfolio holding profit for single
        weight column and specific forward return column'''
        data = self.data.loc[:, [weight_col, forward_col]].copy()
        profit_res = self.__profit(data, weight_col=weight_col, forward_col=forward_col)
        return profit_res

    def holding_profit(self) -> pd.Series:
        '''Calculate holding networth from given data
        ---------------------------------------------

        holding_record: pd.DataFrame, a dataframe with a two-demensional index
            level 0 is the datetime on each reloacte date, level 1 is the asset name
            the column must contain forward return column representing forward return
            `weight` column is optional, if not given, equal weights will be applied.
        return: pd.DataFrame, a dataframe contains networth on each relocate date
        '''
        data = self.data.copy()
        weight_columns = data.columns[data.columns.str.contains('weight')]
        if weight_columns.empty:
            data['weight'] = 1
            weight_columns = ['weight']
        forward_column = get_forward_return_columns(data)
        profits = pd.DataFrame()
        for weight_col in weight_columns:
            forward_result = []
            for forward_col in forward_column:
                profit = self.__profit(data, weight_col=weight_col, forward_col=forward_col)
                profit.index = pd.MultiIndex.from_product([[weight_col], profit.index], names=['weight', 'date'])
                forward_result.append(profit)
            profits = profits.append(pd.concat(forward_result, axis=1))
        self.profits = profits
        return profits

    def _hold_plot(self, ax: plt.Axes, weight: str, period: str):
        '''Plot portfolio holding profit for single
        weight column and specific forward return period'''
        data = self.profits.loc[weight, [f'profit_{period}', f'cum_profit_{period}']].copy()
        ax.set_title(f'layering: {weight} - {period}', fontsize=20)
        ax.bar(data.index, data[f'profit_{period}'], width=8)
        ax.hlines(0, data.index[0], data.index[-1], color='k', linestyle='-.')
        ax = ax.twinx()
        ax.plot(data.index, data[f'cum_profit_{period}'])

    def holding_plot(self, path: str = None) -> None:
        '''Holding Result Plot
        -------------------------

        profits: pd.DataFrame, standardized result generated from holding_profit function
        path: str, path to save the plot, default is None, which means show the plot
        '''
        weights = self.profits.index.levels[0]
        periods = set(self.profits.columns.map(lambda x: x.split('_')[-1]))
        
        _, axes = plt.subplots(len(weights), len(periods), 
            figsize=(len(periods) * 17, len(weights) * 10))
        if len(weights) == 1 and len(periods) == 1:
            axes = np.array([[axes]])
        elif len(weights) == 1 and len(periods) > 1:
            axes = axes.reshape(1, -1)
        elif len(weights) > 1 and len(periods) == 1:
            axes = axes.reshape(-1, 1)

        for i, weight in enumerate(weights):
            for j, period in enumerate(periods):
                self._hold_plot(axes[i, j], weight, period)

        if path is not None:
            plt.savefig(path, bbox_inches='tight')
        else:
            plt.show()


if __name__ == "__main__":
    factors = ['return_1m', 'return_3m']
    dates = trade_date('2011-02-01', '2011-12-31', freq='monthly')
    forward_period = [1, 3]
    data = factor_datas_and_forward_returns(factors, dates, forward_period)
    analyzer = Analyzer(data)
    reg_result = analyzer.regression()
    ic_result = analyzer.ic()
    layer_result = analyzer.layering()
    print(reg_result)
    print(ic_result)
    print(layer_result)