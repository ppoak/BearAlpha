import pandas as pd
import statsmodels.api as sm
from .prepare import *


def _reg(data: pd.DataFrame, factor: str, period: str) -> pd.DataFrame:
    '''Calculate factor regression results for single
    forward return period and one specific factor'''
    data = data.copy()
    grp = pd.get_dummies(data.loc[:, 'group']).iloc[:, :-1]
    x = pd.concat([data.loc[:, factor], grp], axis=1)
    y = data.loc[:, period]
    x = sm.add_constant(x)
    model = sm.OLS(y, x).fit()
    t = model.tvalues[factor]
    coef = model.params[factor]
    return pd.Series({f't_{period}': t, f'coef_{period}': coef})

def _ic(data: pd.DataFrame, factor: str, period: str) -> pd.Series:
    '''Calculate factor ic results for single 
    forward return period and one specific factor'''
    data = data.copy()
    res = data.corr(method='spearman')
    val = res.loc[factor, period]
    return pd.Series({f"ic_{period}": val})

def _layer(data: pd.DataFrame, factor: str, period: str) -> pd.DataFrame:
    '''Calculate factor layering results for single
    forward return period and one specific factor'''
    data = data.copy()
    data[f'{factor}_weight'] = 1
    profit = _profit(data, weight_col=f'{factor}_weight', forward_col=period)
    return profit
    
def _profit(data: pd.DataFrame, weight_col: str, forward_col: str) -> pd.DataFrame:
    '''Calculate portfolio holding profit for single
    weight column and specific forward return column'''
    data = data.copy()
    profit = data.groupby(level='date').apply(lambda x:
        (x[weight_col] * x[forward_col] / x[weight_col].sum()).sum())
    profit = profit.sort_index()
    profit = profit.shift(1).fillna(0)
    profit.name = f'profit_{forward_col}'
    cumprofit = (profit + 1).cumprod()
    cumprofit.name = f'cum_profit_{forward_col}'
    result = pd.concat([profit, cumprofit], axis=1)
    return result

def regression(data: pd.DataFrame) -> pd.DataFrame:
    '''Calculate factor regression results
    --------------------------------------

    data: pd.DataFrame, data must be in the standard format
        generated by function `factor_datas_and_forward_returns`
        in factor/utils/prepare.py
    return: pd.DataFrame, a dataframe with multi-index and columns
        one is t value for each regression; another is coefficient
    '''
    data = data.copy()
    factors = get_factor_columns(data)
    forward = get_forward_return_columns(data)

    results = pd.DataFrame()
    for factor in factors:
        period_result = []
        for period in forward:
            result = data.groupby(level='date').apply(_reg, factor=factor, period=period)
            result.index = pd.MultiIndex.from_product([[factor], result.index], names=['factor', 'date'])
            period_result.append(result)
        results = results.append(pd.concat(period_result, axis=1))
    return results

def ic(data: pd.DataFrame) -> pd.DataFrame:
    '''Calculate factor ic results
    --------------------------------------

    data: pd.DataFrame, data must be in the standard format
        generated by function `factor_datas_and_forward_returns`
        in factor/utils/prepare.py
    return: pd.DataFrame, a dataframe with multi-index and columns
    '''        
    data = data.copy()
    factors = get_factor_columns(data)
    forward = get_forward_return_columns(data)

    results = pd.DataFrame()
    for factor in factors:
        period_result = []
        for period in forward:
            result = data.groupby(level='date').apply(_ic, factor=factor, period=period)
            result.index = pd.MultiIndex.from_product([[factor], result.index], names=['factor', 'date'])
            period_result.append(result)
        results = results.append(pd.concat(period_result, axis=1))
    return results

def layering(data: pd.DataFrame, quantiles: int = 5) -> pd.DataFrame:
    '''Calculate factor layering results
    --------------------------------------

    data: pd.DataFrame, data must be in the standard format
        generated by function `factor_datas_and_forward_returns`
        in factor/utils/prepare.py
    return: pd.DataFrame, a dataframe with multi-index and columns
    '''
    data = data.copy()
    factors = get_factor_columns(data)
    forward = get_forward_return_columns(data)

    results = pd.DataFrame()
    for factor in factors:
        period_result = []
        for period in forward:
            quant = data[factor].groupby(level='date').apply(
                pd.qcut, q=quantiles, labels=False, duplicates='drop')
            data[f'quantiles_{factor}'] = quant + 1
            result = data.groupby(by=f'quantiles_{factor}').apply(_layer, factor=factor, period=period)
            result.index = pd.MultiIndex.from_arrays(
                [[factor] * len(result), result.index.get_level_values(0), result.index.get_level_values(1)],
                names = ['factor', 'quantiles', 'date'])
            period_result.append(result)
        results = results.append(pd.concat(period_result, axis=1))
    return results

def holding_profit(data: pd.DataFrame) -> pd.Series:
    '''Calculate holding networth from given data
    ---------------------------------------------

    holding_record: pd.DataFrame, a dataframe with a two-demensional index
        level 0 is the datetime on each reloacte date, level 1 is the asset name
        the column must contain forward return column representing forward return
        `weight` column is optional, if not given, equal weights will be applied.
    return: pd.DataFrame, a dataframe contains networth on each relocate date
    '''
    data = data.copy()
    weight_columns = data.columns[data.columns.str.contains('weight')]
    if weight_columns.empty:
        data['weight'] = 1
        weight_columns = ['weight']
    forward_column = get_forward_return_columns(data)
    profits = pd.DataFrame()
    for weight_col in weight_columns:
        forward_result = []
        for forward_col in forward_column:
            profit = _profit(data, weight_col=weight_col, forward_col=forward_col)
            profit.index = pd.MultiIndex.from_product([[weight_col], profit.index], names=['weight', 'date'])
            forward_result.append(profit)
        profits = profits.append(pd.concat(forward_result, axis=1))
    return profits
    

if __name__ == "__main__":
    factors = ['return_1m', 'return_3m']
    dates = trade_date('2011-02-01', '2011-12-31', freq='monthly')
    forward_period = [1, 3]
    data = factor_datas_and_forward_returns(factors, dates, forward_period)
    reg_results = regression(data)
    ic_results = ic(data)
    layer_result = layering(data)
    print(reg_results)
    print(ic_results)
    print(layer_result)